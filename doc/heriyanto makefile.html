<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head><title>[lg83]: Creating Makefiles: A Mini Tutorial</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">
    <link rel="stylesheet" href="heriyanto_files/rus-lg.css" type="text/css"></head>


  <body>
    <table align="center" border="0" cellspacing="0" width="95%">
      <tbody><tr>
        <td align="center">
          <hr noshade="noshade" size="2">

          <p><strong>Мини-руководство по созданию Makefile-ов</strong>
	  <br>
          <br>
          Автор: (C) <a href="http://www.linuxgazette.com/authors/heriyanto.html">Tedi
	  Heriyanto</a>
	  <br>
          Перевод: (C) <a href="mailto:kis_an@mail.ru">Андрей
	  Киселев</a></p>
          <hr noshade="noshade" size="2">
        </td>
      </tr>

      <tr>
        <td>
              <p>
      Эта статья представляет собой небольшое руководство по созданию
      Makefile-ов. В ней объясняется для чего нужен Makefile и дается
      несколько правил, которых следует придерживаться при его
      создании.</p>

    <h1><a name="SECTION00010000000000000000">Введение</a></h1>

    <p>Допустим, вы разрабатываете некую программу под названием
    <tt>foo</tt>, состоящую из пяти заголовочных файлов --
    <tt>1.h</tt>, <tt>2.h</tt>, <tt>3.h</tt>, <tt>4.h</tt> и --
    <tt>5.h</tt>, и шести файлов с исходным текстом программы на языке
    С - <tt>1.cpp</tt>, <tt>2.cpp</tt>, <tt>3.cpp</tt>, <tt>4.cpp</tt>,
    <tt>5.cpp</tt> и <tt>main.cpp</tt>. (Хочу заметить, что в реальных
    проектах следует избегать подобного стиля именования файлов).</p>

    <p>Теперь представим себе, что вы обнаружили ошибку в файле
    <tt>2.cpp</tt> и исправили ее. Далее, чтобы получить исправленную
    версию программы вы компилируете все файлы, входящие в состав
    проекта, хотя изменения коснулись только одного файла. Это приводит
    к нерациональной потере времени, особенно если компьютер не слишком
    быстрый.</p>

    <p>Существует ли решение проблемы?</p>

    <p>Не стоит беспокоиться, друзья мои! Эта проблема уже давно
    решена. Опытными программистами была разработана утилита
    <tt>make</tt>. Вместо того, чтобы производить повторную компиляцию
    всех файлов с исходными текстами, она обрабатывает только те файлы,
    которые претерпели изменения. В нашем случае будет скомпилирован
    только один файл - <tt>2.cpp</tt>. Разве это не здорово!?</p>

    <p>Кроме того [<a href="#lpu">2</a>]:</p>

    <ul>
      
      <li>Утилита <tt>make</tt> значительно упрощает жизнь, когда для
      сборки проекта необходимо выполнение длинных и сложных
      команд.</li>

      <li>Проект иногда требует задания редко используемых, а потому
      сложных для запоминания опций компилятора. <tt>make</tt> избавит
      вас от необходимости удерживать их в памяти.</li>

      <li>Единообразие, т.к. работа с этой утилитой поддерживается
      многими средами разработки.</li>

      <li>Процесс сборки можно автоматизировать, поскольку
      <tt>make</tt> может быть вызвана из сценариев или из cron.</li>

    </ul>

    <h1><a name="SECTION00020000000000000000">Для чего нужен Makefile?</a></h1>

    <p>Несмотря на все свои достоинства, утилита <tt>make</tt> ничего
    не знает о нашем проекте, поэтому необходимо создать простой
    текстовый файл, который будет содержать все необходимые инструкции
    по сборке. Файл с инструкциями по сборке проекта называется
    <strong>makefile</strong> <span class="comm-transl">(произносится как
    "мэйкфайл". <strong>прим. перев.</strong>)</span>.</p>

    <p>Как правило этим файлам дается имя <tt>makefile</tt> или
    <tt>Makefile</tt>, в соответствии с соглашениями по именованию
    таких файлов. Если же вы дадите файлу инструкций другое имя, то вам
    потребуется вызывать утилиту make с ключом <tt>-f</tt>.</p>

    <p>Например, если свой makefile вы назвали <tt>bejo</tt>, то
    команда на сборку проекта будет выглядеть так:</p>

<pre>make -f bejo
</pre>

    <h1><a name="SECTION00030000000000000000">Структура файла</a></h1>

    <p>Makefile содержит разделы для <em>"целей"
    [targets]</em>, <em>зависимостей [dependencies]</em> и <em>правил
    (rules)</em> сборки. Все это оформляется следующим образом:
    сначала указывается имя цели (обычно это имя исполняемого или
    объектного файла), после которого следует двоеточие, затем следуют
    имена зависимостей, т.е. файлов, необходимых для получения 
    данной цели. И, наконец, следует список правил: т.е. команд,
    которые необходимо выполнить для получения указанной цели.</p>

    <p>Простой пример структуры makefile'а:</p>

<pre>target: dependencies
        command
        command
        ...
</pre>

    <p>Каждое правило <tt>command</tt> должно начинаться с символа
    табуляции -- это обязательное условие! Отсутствие символа табуляции
    в начале строки с правилом - самая распространенная ошибка. К
    счастью, подобные ошибки легко обнаруживаются, так как утилита
    <tt>make</tt> сообщает о них.</p>

    <h1><a name="SECTION00040000000000000000">Пример Makefile. <!--
            An Example of Makefile
            -->
    </a></h1>

    <p>Ниже приводится простой пример (номера строк добавлены для
    ясности).</p>

<pre>1 client: conn.o
2       g++ client.cpp conn.o -o client

3 conn.o: conn.cpp conn.h
4   g++ -c conn.cpp -o conn.o
</pre>

    <p>В этом примере строка, содержащая текст<br>
     <tt>client: conn.o</tt>,<br>
     называется "строкой зависимостей", а строка<br>
     <tt>g++ client.cpp conn.o -o client</tt><br>
     называется "правилом" и описывает действие, которое
    необходимо выполнить.</p>

    <p>А теперь более подробно о примере, приведенном выше:</p>

    <ul>
      <li>Задается цель -- исполняемый файл <tt>client</tt>, который
      зависит от объектоного файла <tt>conn.o</tt></li>

      <li>Правило для сборки данной цели</li>

      <li>В третьей строке задается цель <tt>conn.o</tt> и файлы, от
      которых она зависит -- <tt>conn.cpp</tt> и <tt>conn.h</tt>.</li>

      <li>В четвертой строке описывается действие по сборке цели
      <tt>conn.o</tt>.</li>

    </ul>

    <h1><a name="SECTION00050000000000000000">Комментарии</a></h1>

    <p>Строки, начинающиеся с символа "#", являются
    комментариями</p>

    <p>Ниже приводится пример makefile с комментариями:</p>

<pre>1 # Создать исполняемый файл "client"
2 client: conn.o
3    g++ client.cpp conn.o -o client
4
5 # Создать объектный файл "conn.o"
6 conn.o: conn.cpp conn.h
7    g++ -c conn.cpp -o conn.o
</pre>

    <h1><a name="SECTION00060000000000000000">"Ложная" цель[</a><a href="#gnum">1</a>]</h1>

    <p>Обычно "ложные" [phony] цели, представляющие
    "мнимое" имя целевого файла, используются в случае
    возникновения конфликтов между именами целей и именами файлов при
    явном задании имени цели в командной строке.</p>

    <p>Допустим в makefile имеется правило, которое не создает ничего,
    например:</p>

<pre>clean:
        rm *.o temp
</pre>

    <p>Поскольку команда <tt>rm</tt> не создает файл с именем
    <tt>clean</tt>, то такого файла никогда не будет существовать и
    поэтому команда <tt>make clean</tt> всегда будет отрабатывать.</p>

    <p>Однако, данное правило не будет работать, если в текущем
    каталоге будет существовать файл с именем <tt>clean</tt>. Поскольку
    цель <tt>clean</tt> не имеет зависимостей, то она никогда не будет
    считаться устаревшей и, соответственно, команда 'rm *.o
    temp' никогда не будет выполнена. <span class="comm-edit">(при
    запуске make проверяет даты модификации целевого файла и тех
    файлов, от которых он зависит. И если цель оказывается
    "старше", то make выполняет соответствующие
    команды-правила -- прим. ред.)</span> Для устранения 
    подобных проблем и предназначена специальная декларация
    <tt>.PHONY</tt>, объявляющая "ложную"
    цель. Например:</p>

<pre>.PHONY : clean
</pre>

    <p>Таким образом мы указываем необходимость исполнения цели, при
    явном ее указании, в виде <tt>make clean</tt> вне зависимости от
    того - существует файл с таким именем или нет.</p>

    <h1><a name="SECTION00070000000000000000">Переменные</a></h1>

    <p>Определить переменную в makefile вы можете следующим
    образом:</p>

<pre>$VAR_NAME=value
</pre>

    <p>В соответствии с соглашениями имена переменных задаются в
    верхнем регистре:</p>

<pre>$OBJECTS=main.o test.o
</pre>

    <p>Чтобы получить значение переменной, необходимо ее имя заключить
    в круглые скобки и перед ними поставить символ '$',
    например:</p>

<pre>$(VAR_NAME)
</pre>

    <p>В makefile-ах существует два типа переменных:
    <em>"упрощенно вычисляемые"</em> и <em>"рекурсивно
    вычисляемые"</em>.</p>

    <p>В рекурсивно вычисляемых переменных все ссылки на другие
    переменные будут замещены их значениями, например:</p>

<pre>TOPDIR=/home/tedi/project
SRCDIR=$(TOPDIR)/src
</pre>

    <p>При обращении к переменной SRCDIR вы получите значение
    <tt>/home/tedi/project/src</tt>.</p>

    <p>Однако рекурсивные переменные могут быть вычислены не всегда,
    например следующие определения:</p>

<pre>CC = gcc -o
CC = $(CC) -O2
</pre>

    <p>выльются в бесконечный цикл. Для разрешения этой проблемы
    следует использовать "упрощенно вычисляемые"
    переменные:</p>

<pre>CC := gcc -o
CC += $(CC) -O2
</pre>
    
    <p>Где символ ':=' создает переменную CC и присваивает ей
    значение "gcc -o". А символ '+=' добавляет
    "-O2" к значению переменной CC.</p>

    <h1><a name="SECTION00080000000000000000">Заключение</a></h1>

    <p>Я надеюсь, что это краткое руководство содержит достаточно
    информации, чтобы начать создавать свои makefile. А за сим --
    успехов в работе.</p>

    <h2><a name="SECTION00090000000000000000">Библиография</a></h2>

    <ul>
      <li><a name="gnum"><sup>1</sup></a> GNU Make Documentation File, info
      make.</li>

      <li><a name="lpu"><sup>2</sup></a> Kurt Wall, et.al., <em>Linux
      Programming Unleashed <span class="comm-edit">(Программирование
       под Linux на оперативном просторе -- прим. ред.)</span></em>, 2001.</li>
    </ul>
          <hr noshade="noshade" size="2">
	   <p align="center"><strong>Copyright (C)  2002, Tedi Heriyanto.<br>
	   Copying license <a href="http://www.linuxgazette.com/copying.html">http://www.linuxgazette.com/copying.html 
	   </a></strong></p> 
        </td>
      </tr>

      <tr>
        <td align="center">
          <hr noshade="noshade" size="2">
          <a href="http://gazette.linux.ru.net/">Вернуться на главную
          страницу</a> 
          <hr noshade="noshade" size="2">
        </td>
      </tr>
    </tbody></table>
  </body></html>